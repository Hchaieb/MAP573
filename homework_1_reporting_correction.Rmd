---
title: 'Homework #1: correction'
subtitle: 'Swirl, Rmarkdown reporting and first analyses'
author: 'MAP573 team'
date: "09/29/2020"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  cache = TRUE,
  echo  = TRUE,
  rows.print = 5)
```

## Preliminaries

Let us load a couple of packages useful in our analyses:

```{r}
library(tidyverse)
```

## Part 1: Swirl

A bit long but not so complicated...

## Part 2: Basic exploratory data analysis

The ['fertility.csv'](https://raw.githubusercontent.com/jchiquet/MAP573/master/data/fertility.csv) data set contains the female fertility in Europe in 2012 for 39 European countries splitted by age groups  15-19, 20-24, 25-29, 30-34, 35-39, 40 and over. The fertility is given as the mean number of children born per 1000 women.

1. Download and read the data set from the data directory of MAP573's github repository (use, e.g. `read.csv`). Store it into a data frame called fertility.

```{r fertilily}
## base R
fertility <- read.csv("data/fertility.csv", row.names = 1, header = TRUE) %>% as_tibble()
## readr
fertility <- read_csv("data/fertility.csv") %>% select(-id)
```

2. Display the first 10 rows in the R markdown report.

```{r}
fertility %>% head() %>% knitr::kable()
```

3. Make a summary of the data and display it (command `summary`)

The **tibble**'s command `glimpse` let you have a quick overview of the structure of your table:

```{r glimpse}
fertility %>% tibble::glimpse()
```

`summary` gives a summary statistics of each column, dependnign on its type (factor, numeric)

```{r summary}
fertility %>% summary()
```


4. Find the country and age group with the highest, smallest value in each Region

Let us do this with a mix f tidyverse and base R tools:

```{r }
fertility %>% 
  group_by(Region) %>% 
  summarise(
    `fertility min `     = min(Fertilite),
    `smallest (Country)` = Pays[which.min(Fertilite)],
    `smallest (Age)`     = Age[which.min(Fertilite)],
    `fertility max `     = max(Fertilite),
    `highest (Country)`  = Pays[which.max(Fertilite)],
    `highest (Age)`      = Age[which.max(Fertilite)])
```

4. Display boxplots of the fertility for each age group

I first relevel the levels in Age

```{r}
fertility %>% 
  mutate(Age = fct_relevel(Age, c("15-19", "20-24", "25-29", "30-34", "35-39", ">=40"))) %>%  
  ggplot() + aes(x = Age, y = Fertilite) + geom_boxplot()
```

As a bonus, split by region:

```{r Region}
fertility %>% 
  mutate(Age = fct_relevel(Age, c("15-19", "20-24", "25-29", "30-34", "35-39", ">=40"))) %>%  
  ggplot() + aes(x = Age, y = Fertilite, fill = Region) + geom_boxplot() + geom_jitter(alpha = 0.5, size = 1)
```


5. Display boxplots of the fertility for each 'Region' for the youngest age group

```{r Region youngest}
fertility %>% 
  filter(Age == "15-19") %>% 
  group_by(Region) %>% 
  ggplot() + aes(x = Region, y = Fertilite) + geom_boxplot()
```

7. Extract all the data rows with Country starting by "A"

```{r}
filter(fertility, str_detect(Pays, "^A"))
```

8. Extract the fertility values of the Region from North Europe and make a histogram

```{r}
fertility %>% 
  filter(Region == 'Europe nord') %>% 
  ggplot() + aes(x = Fertilite) + geom_histogram(binwidth = 10)
```

9. Extract the fertility values of the Region from East Europe and plot a kernel density estimate (function `density`)

```{r}
fertility %>% 
  filter(Region == 'Europe est') %>% pull(Fertilite) %>% 
  density() %>% plot()
```

10. Include in your report the mathematical expression of the kernel density estimator as given at [https://en.wikipedia.org/wiki/Kernel_density_estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation)

Here it is:

\[
\widehat{f}_h(x) = \frac{1}{n}\sum_{i=1}^n K_h (x - x_i) = \frac{1}{nh} \sum_{i=1}^n K\Big(\frac{x-x_i}{h}\Big),
\]

## Part 3: Basic handling of missing values

The ['ozoneNA.csv'](https://raw.githubusercontent.com/jchiquet/MAP573/master/data/ozoneNA.csv) data set contains 112 observations about air pollution collected during the summer of 2001 in Rennes. The aim of this study is to analyze the relationship between the maximum daily ozone level (maxO3) and the other meteorological variables. Hence, the variables recorded in this data set are the following:

- maxO3 (maximum daily ozone)
- maxO3v (maximum daily ozone the previous day)
- T12 (temperature at midday)
- T9 (Temp at 9am)
- T15 (Temp at 3pm)
- Vx12 (projection of the wind speed vector on the east-west axis at midday)
- Vx9 and Vx15 (same at 9am and 3pm)
- Ne9, Ne12, Ne15 Nebulosity (cloud)

This data is incomplete - there are missing values. Indeed, it occurs frequently to have machines that fail one day, leading to some information not recorded. In this exercice, we will perform extremely basic imputation of missing values for the variable `maxO3`, measuring the maximum value of ozone of the day.

1. Import the data as a data frame named `ozone`.

2. Represent an histogram of the variable `maxO3`.

3. Perform a _very_ basic imputation by replacing `NA` values in ` maxO3` by the mean value. Create a vector `maxO3_NA_mean`.

4. We suggest now to perform imputation via the k-nearest neighbor approach (see [https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm) ). Use the package **simputation** to perform knn-imputation of the missing-value in `maxO3` based on a distance computed with all remaming variable. To do so, use

```{r, eval = FALSE}
simputation::impute_knn(ozone, maxO3 ~ .)
```

where `ozone` is your data frame. The string `maxO3 ~ .` is a formula explaining that `maxO3` is the variable on which imputation must be performed, and while `~ .` says that all remaining variables of the data frame are used to perform the imputation. Create a vector `maxO3_NA_knn` with the vector with imputed values.

5. Compare visually the distributions of the three vectors `maxO3`,`maxO3_NA_mean` and `maxO3_NA_knn`.

